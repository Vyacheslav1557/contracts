// Auto-generated by https://github.com/vladkens/apigen-ts
// Source: ./tester/v1/openapi.yaml

type Headers = Record<string, string>;
export type ApigenHeaders =
  | Headers
  | ((method: string, path: string) => Headers | Promise<Headers>);

export interface ApigenConfig {
  baseUrl: string;
  headers: ApigenHeaders;
}

export interface ApigenRequest extends Omit<RequestInit, "body"> {
  search?: Record<string, unknown>;
  body?: unknown;
}

export class ApiClient {
  Config: ApigenConfig;

  constructor(config?: Partial<ApigenConfig>) {
    this.Config = { baseUrl: "/", headers: {}, ...config };
  }

  async ParseError(rep: Response) {
    try {
      return await rep.json();
    } catch (e) {
      throw rep;
    }
  }

  PrepareFetchUrl(path: string): URL {
    let base = this.Config.baseUrl;
    if ("location" in globalThis && (base === "" || base.startsWith("/"))) {
      const { location } = globalThis as unknown as {
        location: { origin: string };
      };
      base = `${location.origin}${base.endsWith("/") ? base : `/${base}`}`;
    }

    return new URL(path, base);
  }

  async Fetch<T>(
    method: string,
    path: string,
    opts: ApigenRequest = {},
  ): Promise<T> {
    const url = this.PrepareFetchUrl(path);

    for (const [k, v] of Object.entries(opts?.search ?? {})) {
      url.searchParams.append(
        k,
        Array.isArray(v) ? v.join(",") : (v as string),
      );
    }

    const configHeaders =
      typeof this.Config.headers === "function"
        ? await this.Config.headers(method, path)
        : this.Config.headers;

    const headers = new Headers({ ...configHeaders, ...opts.headers });
    const ct = headers.get("content-type") ?? "application/json";

    let body: FormData | URLSearchParams | string | undefined = undefined;

    if (
      ct === "multipart/form-data" ||
      ct === "application/x-www-form-urlencoded"
    ) {
      headers.delete("content-type");
      body =
        ct === "multipart/form-data" ? new FormData() : new URLSearchParams();
      for (const [k, v] of Object.entries(
        opts.body as Record<string, string>,
      )) {
        body.append(k, v);
      }
    }

    if (ct === "application/json" && typeof opts.body !== "string") {
      headers.set("content-type", "application/json");
      body = JSON.stringify(opts.body);
    }

    const credentials = opts.credentials ?? "include";
    const rep = await fetch(url.toString(), {
      method,
      ...opts,
      headers,
      body,
      credentials,
    });
    if (!rep.ok) throw await this.ParseError(rep);

    const rs = await rep.text();
    try {
      return JSON.parse(rs) as T;
    } catch (e) {
      return rs as unknown as T;
    }
  }

  general = {
    listProblems: (search: {
      page?: number;
      pageSize?: number;
      title?: string;
      order?: number;
    }) => {
      return this.Fetch<ListProblemsResponse>("get", "/problems", { search });
    },

    createProblem: (search: { title?: string }) => {
      return this.Fetch<CreationResponse>("post", "/problems", { search });
    },

    getProblem: (id: number) => {
      return this.Fetch<GetProblemResponse>("get", `/problems/${id}`, {});
    },

    uploadProblem: (id: number, body: UploadProblemRequest) => {
      return this.Fetch<void>("post", `/problems/${id}`, {
        body,
        headers: { "content-type": "multipart/form-data" },
      });
    },

    updateProblem: (id: number, body: UpdateProblemRequest) => {
      return this.Fetch<void>("patch", `/problems/${id}`, { body });
    },

    deleteProblem: (id: number) => {
      return this.Fetch<void>("delete", `/problems/${id}`, {});
    },

    listContests: (search: { page?: number; pageSize?: number }) => {
      return this.Fetch<ListContestsResponse>("get", "/contests", { search });
    },

    createContest: (search: { title?: string }) => {
      return this.Fetch<CreationResponse>("post", "/contests", { search });
    },

    getContest: (contest_id: number) => {
      return this.Fetch<GetContestResponse>(
        "get",
        `/contests/${contest_id}`,
        {},
      );
    },

    updateContest: (contest_id: number, body: UpdateContestRequest) => {
      return this.Fetch<void>("patch", `/contests/${contest_id}`, { body });
    },

    deleteContest: (contest_id: number) => {
      return this.Fetch<void>("delete", `/contests/${contest_id}`, {});
    },

    createContestProblem: (
      contest_id: number,
      search: {
        problem_id?: number;
      },
    ) => {
      return this.Fetch<CreationResponse>(
        "post",
        `/contests/${contest_id}/problems`,
        { search },
      );
    },

    getContestProblem: (problem_id: number, contest_id: number) => {
      return this.Fetch<GetContestProblemResponse>(
        "get",
        `/contests/${contest_id}/problems/${problem_id}`,
        {},
      );
    },

    deleteContestProblem: (problem_id: number, contest_id: number) => {
      return this.Fetch<void>(
        "delete",
        `/contests/${contest_id}/problems/${problem_id}`,
        {},
      );
    },

    listParticipants: (
      contest_id: number,
      search: {
        page?: number;
        pageSize?: number;
      },
    ) => {
      return this.Fetch<ListUsersResponse>(
        "get",
        `/contests/${contest_id}/participants`,
        { search },
      );
    },

    createParticipant: (
      contest_id: number,
      search: {
        user_id?: string;
      },
    ) => {
      return this.Fetch<CreationResponse>(
        "post",
        `/contests/${contest_id}/participants`,
        { search },
      );
    },

    deleteParticipant: (
      contest_id: number,
      search: {
        user_id?: string;
      },
    ) => {
      return this.Fetch<void>(
        "delete",
        `/contests/${contest_id}/participants`,
        { search },
      );
    },

    listSolutions: (search: {
      page?: number;
      pageSize?: number;
      contestId?: number;
      userId?: string;
      problemId?: number;
      state?: number;
      order?: number;
      language?: number;
    }) => {
      return this.Fetch<ListSolutionsResponse>("get", "/solutions", { search });
    },

    createSolution: (
      body: CreateSolutionRequest,
      search: {
        problem_id?: number;
        contest_id?: number;
        language?: number;
      },
    ) => {
      return this.Fetch<CreationResponse>("post", "/solutions", {
        search,
        body,
        headers: { "content-type": "multipart/form-data" },
      });
    },

    getSolution: (solution_id: number) => {
      return this.Fetch<GetSolutionResponse>(
        "get",
        `/solutions/${solution_id}`,
        {},
      );
    },

    getMonitor: (contest_id: number) => {
      return this.Fetch<GetMonitorResponse>(
        "get",
        `/contests/${contest_id}/monitor`,
        {},
      );
    },

    getHealth: () => {
      return this.Fetch<{
        status?: string;
        message?: string;
      }>("get", "/health", {});
    },

    getMe: () => {
      return this.Fetch<GetUserResponse>("get", "/users/me", {});
    },

    getUser: (id: string) => {
      return this.Fetch<GetUserResponse>("get", `/users/${id}`, {});
    },
  };
}

export type Contest = {
  id: number;
  title: string;
  created_at: string;
  updated_at: string;
};

export type ContestProblem = {
  problem_id: number;
  title: string;
  time_limit: number;
  memory_limit: number;
  position: number;
  legend_html: string;
  input_format_html: string;
  output_format_html: string;
  notes_html: string;
  scoring_html: string;
  created_at: string;
  updated_at: string;
};

export type ContestProblemListItem = {
  problem_id: number;
  position: number;
  title: string;
  memory_limit: number;
  time_limit: number;
  created_at: string;
  updated_at: string;
};

export type CreateSolutionRequest = {
  solution: File;
};

export type CreationResponse = {
  id: number;
};

export type GetContestProblemResponse = {
  problem: ContestProblem;
};

export type GetContestResponse = {
  contest: Contest;
  problems: ContestProblemListItem[];
};

export type GetMonitorResponse = {
  participants: ParticipantsStat[];
  summary: ProblemStatSummary[];
};

export type GetProblemResponse = {
  problem: Problem;
};

export type GetSolutionResponse = {
  solution: Solution;
};

export type GetUserResponse = {
  user: User;
};

export type ListContestsResponse = {
  contests: Contest[];
  pagination: Pagination;
};

export type ListProblemsResponse = {
  problems: ProblemsListItem[];
  pagination: Pagination;
};

export type ListSolutionsResponse = {
  "access-token": string;
  solutions: SolutionsListItem[];
  pagination: Pagination;
};

export type ListUsersResponse = {
  users: User[];
  pagination: Pagination;
};

export type Pagination = {
  page: number;
  total: number;
};

export type ParticipantsStat = {
  user_id: string;
  username: string;
  solved: number;
  penalty: number;
  attempts: ProblemAttempts[];
};

export type Problem = {
  id: number;
  title: string;
  time_limit: number;
  memory_limit: number;
  legend: string;
  input_format: string;
  output_format: string;
  notes: string;
  scoring: string;
  legend_html: string;
  input_format_html: string;
  output_format_html: string;
  notes_html: string;
  scoring_html: string;
  created_at: string;
  updated_at: string;
};

export type ProblemAttempts = {
  problem_id: number;
  position: number;
  failed_attempts: number;
  state: number | null;
};

export type ProblemStatSummary = {
  problem_id: number;
  position: number;
  s_attempts: number;
  f_attempts: number;
  t_attempts: number;
};

export type ProblemsListItem = {
  id: number;
  title: string;
  memory_limit: number;
  time_limit: number;
  created_at: string;
  updated_at: string;
};

export type Solution = {
  id: number;
  user_id: string;
  username: string;
  solution: string;
  state: number;
  score: number;
  penalty: number;
  time_stat: number;
  memory_stat: number;
  language: number;
  problem_id: number;
  problem_title: string;
  position: number;
  contest_id: number;
  contest_title: string;
  updated_at: string;
  created_at: string;
};

export type SolutionsListItem = {
  id: number;
  user_id: string;
  username: string;
  state: number;
  score: number;
  penalty: number;
  time_stat: number;
  memory_stat: number;
  language: number;
  problem_id: number;
  problem_title: string;
  position: number;
  contest_id: number;
  contest_title: string;
  updated_at: string;
  created_at: string;
};

export type UpdateContestRequest = {
  title?: string;
};

export type UpdateProblemRequest = {
  title?: string;
  legend?: string;
  input_format?: string;
  output_format?: string;
  notes?: string;
  scoring?: string;
  memory_limit?: number;
  time_limit?: number;
};

export type UploadProblemRequest = {
  archive: File;
};

export type User = {
  id: string;
  username: string;
  createdAt: string;
  updatedAt: string;
  role: string;
};
